{% doc %}
  Adds subtle scroll-triggered fade-in animations to elements.

  Include this snippet once in each section that needs animations.
  Add the 'scroll-animate' class to elements you want to animate.

  @example
  {% render 'scroll-animation' %}

  <div class="scroll-animate">Content fades in</div>
{% enddoc %}

{% stylesheet %}
  /* Scroll Animation - Initial hidden state */
  .scroll-animate {
    opacity: 0;
    transform: translateY(16px);
    transition: opacity 0.5s cubic-bezier(0.25, 0.1, 0.25, 1),
                transform 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
    will-change: opacity, transform;
  }

  /* Visible state */
  .scroll-animate.is-visible {
    opacity: 1;
    transform: translateY(0);
  }

  /* Fallback: show content if JS fails or takes too long */
  .no-js .scroll-animate,
  .scroll-animate.is-visible {
    opacity: 1;
    transform: translateY(0);
  }

  /* Reduced motion preference - show immediately without animation */
  @media (prefers-reduced-motion: reduce) {
    .scroll-animate {
      opacity: 1;
      transform: none;
      transition: none;
    }
  }
{% endstylesheet %}

{% javascript %}
  (function() {
    // Prevent multiple initializations
    if (window.scrollAnimationReady) return;
    window.scrollAnimationReady = true;

    // Check for reduced motion preference
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReducedMotion) {
      document.querySelectorAll('.scroll-animate').forEach(el => el.classList.add('is-visible'));
      return;
    }

    // Observer with settings optimized for earlier trigger
    const observerOptions = {
      root: null,
      rootMargin: '50px 0px 0px 0px', // Trigger 50px BEFORE entering viewport
      threshold: 0
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          // Small delay for smoother perceived performance
          requestAnimationFrame(() => {
            entry.target.classList.add('is-visible');
          });
          observer.unobserve(entry.target);
        }
      });
    }, observerOptions);

    function initScrollAnimations() {
      const elements = document.querySelectorAll('.scroll-animate:not(.is-visible)');

      elements.forEach(el => {
        // Check if element is already in viewport (above fold)
        const rect = el.getBoundingClientRect();
        const isInViewport = rect.top < window.innerHeight && rect.bottom > 0;

        if (isInViewport) {
          // Element already visible - animate immediately with slight stagger
          requestAnimationFrame(() => {
            el.classList.add('is-visible');
          });
        } else {
          // Element below fold - observe for scroll
          observer.observe(el);
        }
      });
    }

    // Initialize
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initScrollAnimations);
    } else {
      // DOM ready - run on next frame to ensure styles are applied
      requestAnimationFrame(initScrollAnimations);
    }

    // Re-initialize when Shopify section is rendered in editor
    document.addEventListener('shopify:section:load', () => {
      requestAnimationFrame(initScrollAnimations);
    });
  })();
{% endjavascript %}
